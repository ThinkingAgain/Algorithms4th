# 3.3平衡查找树
一种能够保证符号表API中所有操作（范围查找除外）均能够在对数时间内完成的数据结构。
## 1、2-3查找树
### 定义：
由2-结点（含有一个键和两个链接）和3-结点（含有两个键和三条链接）组成。完美平衡的2-3查找树：其所有空链接到根结点的距离都是相同的。
### 查找：
和二叉查找树的查找算法类似
### 插入新键：
1. #### 向2-结点中插入新键
   先进行查找，如果未命中的查找结束于一个2-结点，将其替换为一个3-结点即可。
2. #### 向一棵只含一个3-结点的树中插入新键 
   * 临时将新键存入3-结点，使之成为一个4-结点。
   * 将4-结点转换为一棵由3个2-结点组成的2-3树。
3. #### 向一个父结点为2-结点的3-结点中插入新键
   * 临时将新键存入3-结点，使之成为一个4-结点。
   * 将4-结点中的中键上移至父结点，左右两键分裂为两个新的2-结点。中键的左右两个链接分别指向两个新的2-结点。
4. #### 向一个父结点为3-结点的3-结点中插入新键。
   * 采用（3）的方式：构造临时4-结点，然后分解插入父结点。
   * 一直不断分解上插，直到遇到一个2-结点。
   * 或者一路全是3-结点，这样就把根结点变为4-结点。
5. #### 分解根结点
   * 分解4-结点的根结点，可采用（2）的方式，将根结点分解为3个2-结点。
### 2-3树的变换为局部变换
  * 2-3树插入算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必修改或检查树的其他部分。
  * 每次变换中，变更的链接数量不会超过一个很小的常数。
### 全局性质
  * 2-3树是向上生长的。
  * 所有局部变换都不会影响整个树的有序性和平衡性。
  * 只有当根结点分解为3个2-结点时，所有路径长度才会加1.
---
> ## 命题F： 在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lg*N*个。
---
## 2、红黑二叉查找树
```2-3查找树的一种实现。```
- ### 1）基本定义
  - #### 基本思想：
    用标准的二叉查找树（完全由2- 结点构成） 和一些额外的信息（替换3- 结点）来表示2-3树。
  - #### 两种类型的链接：
    - 红链接：左斜相连的两个2- 结点，构成一个3- 结点。
    - 黑链接：普通2- 结点连接。
- ### 2）另一种等价的定义
  #### 含有红黑链接并满足下列条件的二叉查找树：
    - 红链接均为左链接
    - 没胡任何一个结点同时和两条红链接相连
    - 该树是**完美黑色平衡**的， 即任意空链接到根结点的路径上的黑链接数量相同。
- ### 3）红黑颜色表示
  - #### 结点的颜色指的是指向该结点的链接的颜色
  - #### 颜色保存在Node的布尔变量color中。红色为true, 黑色为false.
  - #### 约定空链接为黑色。
  - #### 使用私有方法isRed()来测试结点颜色。

- ### 4）旋转
  - #### 左旋转
    将红色右链接转化为左链接。对应方法参数为：红色右链接的结点；返回：旋转后的新的子树根结点
  - #### 右旋转
    方法完全相同，只不过将left换成right即可。

- ### 5）插入操作
  - #### 向2- 结点插入新键
    新键<老键：直接新增一个红色左链接
    新键>老键：新增一个红色右链接，然后旋转。

  - ### 向一棵双键树（即一个 3- 结点）中插入新键
    有三种子情况，每种子情况都会产生一个同时连接到两条红链接的结点（4-结点的中间结点）。
    - #### 新键 > 双键：新键连接到3-结点的右链接，成为一个有两条红链接的4-结点
    - #### 新键 < 双键：新键连接到最左边的空链接，形成两条连续的左斜红链接，只需将上层红链接右旋即可。
    - #### 新键介于双键之间：会产生一条左斜红链接接一条右斜红链接，只需将下层红链接右旋即可。
    总的来说，分别通过0次、1次和2次旋转以及颜色变化得到期望的结果。

- ### 6）颜色转换
  用方法flipColors()来转换一个结点的两个红色子结点的颜色。除将子结点的颜色由红变黑外，同时还将父结点的颜色由黑变红。此变换为局部变换，不会影响整棵树的黑色平衡性。

- ### 7)根结点总是黑色
  颜色转换会将父结点由黑变红，但当父结点为根结点时，应将其设为黑色，树的黑链接高度会增加1.

- ### 8）向树底部的 3- 结点插入新键，并将红链接在树中向上传递
  - #### （1）插入新结点
  - #### （2）对形成的4- 结点进行旋转和颜色转换
    - ##### 如果左-黑右-红，则进行左旋转
    - ##### 如果左-红 且左子结点也是左-红，则进行右旋转
    - ##### 如果左-红右-红， 则进行颜色转换
  - #### （3）如果父结点是3- 结点会形成新的4- 结点，继续按（2）的步骤进行旋转和颜色转换
  - #### （4）持续向上传递，直到遇到2- 结点或根结点

## 3、实现

## 4、删除操作
    删除操作比插入操作更复杂，不仅要在（为了删除一个结点而）构造临时4- 结点时沿着查找路径向下进行变换，还要在分解遗留的4- 结点时沿着查找路径向上进行变换（同插入操作）
    研究删除操作前先进行两轮热身：
- ### 1）*第一轮热身*：自顶向下的2-3-4 树插入算法
    首先沿查找路径向下进行变换是为了保证当前结点不是4-结点（这样树底才有空间插入新键），沿查找路径向上进行变换是为了将之前创建的4-结点配平。
  - #### （1）将4-结点表示为三个2-结点组成的一棵平衡的子树，根结点和两个子结点都用红链接相连；
  - #### （2） 在向下的过程中分解所有4- 结点并进行颜色转换；
  - #### （3） 和插入操作一样，在向上的过程中用旋转将4-结点配平。
- ### 2）*第二轮热身*：删除最小键
  避免树的底部不是2-结点，才会在删除最小键后保持树的平衡性。因此我们沿着左链接向下进行变换，确保当前结点不是2-结点。
  沿左链接向下的过程中，保证以下情况之一成立：
  - #### 如果当前结点的左子结点不是2- 结点，完成；
  - #### 如果当前结点的左子结点是2- 结点而它的亲兄弟结点不是2- 结点，将左子结点的兄弟结点中的一个键移动到左子结点中；
  - #### 如果当前结点的左子结点和它的新兄弟结点都是2- 结点，将左子结点、父结点中的最小键和左子结点最近的兄弟结点合并为一个4- 结点，使父结点由3- 结点变成2- 结点或者由4- 结点变为3- 结点。
  ```执行以上过程，最后能够得到一个含有最小键的3-结点或4-结点，然后我们就可以直接从中将其删除。然后再回头向上分解所有临时的4-结点。```
- ### 3) 真正的删除操作
  在查找路径上进行和删除最小键相同的变换，保证当前结点不是2-结点。如果被查找的键在树的底部，直接删除它。如果不在底部，需要将它和它的后继结点交换？（和二叉查找树一样）。删除之后，需要向上回溯并分解余下的4-结点。

## 5、红黑树的性质
> 所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别

- ### 1）性能分析
---
> ## 命题G：一棵大小为 *N* 的红黑树的高度不会超过 *2logN*。
---
> ## 命题H: 一棵大小为 *N* 的红黑树中，根结点到任意结点的平均路径长度为 *~1.00lgN* 。
---
- ## 2）有序符号表API
---
> ## 命题I：在一棵红黑树中，以下操作在最坏情况下所需的时间是对数级别的：查找（get()）、插入（put()）、查找最小键、查找最大键、floor()、ceiling()、rank()、select()、删除最小键（deleteMin()）、删除最大键（deleteMax()）、删除（delete()）和范围查询（range()）。
---