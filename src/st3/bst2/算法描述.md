
### 删除最大键和删除最小键
1. #### deleteMin(root) -> root 传入根结点，返回删除最小值后的根结点
* ##### 算法思路
  1. 不断深入根结点的左子树中直到遇见一个结点的左子树为空，此结点标为t。即`t.left == null`
  2.  将指向t的链接 **指向t的右子树**
* ##### 算法步骤
  递归方法-Node deleteMin(Node x)：
  ```{.line-numbers}
  左子树为空 ： 返回右子树
  左子树不为空：左子树 = deleteMin(左子树)
  更新当前结点的结点计数器N
  返回当前结点
  ```  
2. #### deleteMax()
* 在根结点的右子树中进行类似的操作。
---
### 删除结点x操作 void delete(x) 
* ##### 算法思路
  1. 用x的后继结点填补它的位置
  2. x的后继结点为它右子树中的最小结点
* ##### 算法描述
```{.line-numbers}
将要被删除结点x位置替换成它的后继结点，即min(x.right)
将后继结点的右链接->deleteMin(x.right) （删除最小结点后的x右子树）
将后继结点的左链接->x.left
修正x结点至根结点的结点计数器N值
```
### 范围查找 - 返回给定范围内键的keys(lo, hi)方法
1. #### 中序遍历 - 顺序遍历二叉树的基本方法
* ##### 算法思路
  1. 通过递归调用向左子树下探，直到遇到结点小于lo; 再取此结点的右子树向左继续下探，直到再次遇到小于lo的结点或到达树的尽头。目的是找到（lo, hi)范围内的最小键。
  2. 将此键压入队列，再通过递归调用进入其右子树，向左下探，目的是找到范围内的第二小的键。以此类推。
  3. 依递归按原路返回，这样范围内的键就依次进入队列。
* ##### 算法步骤
```{.line-numbers}
递归调用：keys（x结点，队列，lo, hi)
x结点为空：返回
x>lo: 递归调用keys(x的左子树, 队列，lo, hi)
x在范围[lo, hi]内：x压入队列
x<hi: 递归调用keys(x的右子树， 队列，lo, hi)
```